import { createClient } from '@supabase/supabase-js'
import { withTimeoutMonitoring } from './_middleware/timeout-monitor.js'

/**
 * SCHEMA_VERSION: 2025-08-26
 * Auto-generated by schema-validator.js
 * Run 'npm run validate-schema' to ensure schema compliance
 */


const handlerFunction = async (event) => {
  // CORS preflight
  if (event.httpMethod === 'OPTIONS') {
    return {
      statusCode: 200,
      headers: {
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'Content-Type',
        'Access-Control-Allow-Methods': 'GET, POST, OPTIONS'
      },
      body: ''
    }
  }

  // Environment variables check
  const supabaseUrl = process.env.SUPABASE_URL
  const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY

  if (!supabaseUrl || !supabaseKey) {
    console.error('‚ùå Missing Supabase credentials')
    return {
      statusCode: 500,
      headers: { 'Access-Control-Allow-Origin': '*' },
      body: JSON.stringify({
        error: 'Missing Supabase credentials',
        details: 'SUPABASE_URL and SUPABASE_SERVICE_ROLE_KEY must be set'
      })
    }
  }

  const supabase = createClient(supabaseUrl, supabaseKey)

  // Function to generate fresh forecast (bypassing cache)
  async function generateFreshForecast() {
    console.log('üéØ Generating fresh forecast (cache bypassed)')

    // Get current events count
    let currentEventsCount = 0
    try {
      const { count: eventsCountData, error: countError } = await supabase
        .from('events')
        .select('*', { count: 'exact', head: true })

      if (!countError && eventsCountData !== null) {
        currentEventsCount = eventsCountData
      }
    } catch (countErr) {
      console.warn('‚ö†Ô∏è Events count lookup failed:', countErr)
    }

    console.log(`üìä Current events count: ${currentEventsCount}`)

    // Try to fetch from Python service first
    // Check if we're running in Netlify (either NETLIFY=true or AWS_LAMBDA_FUNCTION_NAME set)
    const isNetlify = (process.env.NETLIFY === 'true') || !!process.env.AWS_LAMBDA_FUNCTION_NAME
    const isDev = (process.env.NODE_ENV === 'development') || (process.env.NETLIFY_DEV === 'true')
    const shouldCallPython = isNetlify && !isDev

    console.log('üåç Environment check:')
    console.log('  NETLIFY:', process.env.NETLIFY, '(should be "true" or undefined)')
    console.log('  AWS_LAMBDA_FUNCTION_NAME:', process.env.AWS_LAMBDA_FUNCTION_NAME ? 'Set' : 'Not set')
    console.log('  NODE_ENV:', process.env.NODE_ENV, '(should be "production" in prod)')
    console.log('  NETLIFY_DEV:', process.env.NETLIFY_DEV, '(should be "true" in dev)')
    console.log('  isNetlify:', isNetlify, '(should be true in Netlify)')
    console.log('  isDev:', isDev, '(should be false in production)')
    console.log('  shouldCallPython:', shouldCallPython, '(should be true for Python service calls)')

    let forecastData = null

    if (shouldCallPython) {
      console.log('üîç Fetching fresh forecast from Python service...')
      const pythonServiceUrl = process.env.PYTHON_SERVICE_URL || 'https://forecasting-service.fly.dev'
      const forecastEndpoint = `${pythonServiceUrl}/forecast/fresh`

      try {
        const res = await fetch(forecastEndpoint, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ currentEventsCount })
        })

        if (!res.ok) {
          throw new Error(`${res.status} ${res.statusText}`)
        }

        forecastData = await res.json()
        console.log('‚úÖ Python service success - MAPE:', forecastData.mape)
      } catch (fetchErr) {
        console.error('‚ùå Python service error:', fetchErr.message)
        console.error('‚ùå Error type:', fetchErr.name)
        forecastData = null // Will fall through to local generation
      }
    }

    // If no external service data, generate local forecast
    if (!forecastData) {
      console.log('üîß Generating local forecast for development...')

      // Generate completely new forecast
      console.log('üé≤ Generating new mock forecast for development')
      const mockForecast = 150 + Math.random() * 50 // 150-200 range
      const today = new Date()
      const futureData = []

      for (let i = 1; i <= 7; i++) {
        const futureDate = new Date(today)
        futureDate.setDate(today.getDate() + i)
        const dayOfWeek = futureDate.getDay()

        // Weekend effect (Sat=6, Sun=0)
        const weekendMultiplier = (dayOfWeek === 0 || dayOfWeek === 6) ? 0.7 : 1.0

        // Daily variation ¬±20%
        const dailyVariation = 0.8 + Math.random() * 0.4

        const predictedValue = mockForecast * weekendMultiplier * dailyVariation

        futureData.push({
          ds: futureDate.toISOString().split('T')[0],
          yhat: Math.round(predictedValue),
          yhat_lower: Math.round(predictedValue * 0.6),
          yhat_upper: Math.round(predictedValue * 1.8)
        })
      }

      forecastData = {
        forecast: mockForecast,
        mape: 12.5, // Fixed realistic MAPE for development testing
        future: futureData,
        metadata: {
          algorithm: 'fresh-mock-for-development',
          source: 'local-generation',
          forcedRefresh: true
        }
      }
    }

    // Store new forecast
    let newEntry = null
    try {
      // Try to insert with new columns first
      let insertData = {
        forecast: forecastData.forecast,
        mape: forecastData.mape,
        future: forecastData.future,
        generated_at: new Date().toISOString()
      }

      // Only add new columns if they exist (to handle missing migration)
      try {
        // Test if the columns exist by doing a quick select
        await supabase.from('forecasts').select('events_count_at_generation').limit(1)
        // If no error, columns exist
        insertData.events_count_at_generation = currentEventsCount
        insertData.model_version = forecastData.metadata?.modelVersion || '1.0'
      } catch (colError) {
        console.log('üìù Using legacy forecast table schema (new columns not available)')
      }

      const { data, error: insertError } = await supabase
        .from('forecasts')
        .insert(insertData)
        .select()
        .single()

      if (insertError) throw insertError
      newEntry = data
      console.log('üíæ Stored new forecast with events_count:', currentEventsCount)
    } catch (dbErr) {
      console.error('‚ùå Error storing forecast:', dbErr)
    }

    return {
      statusCode: 200,
      headers: { 'Access-Control-Allow-Origin': '*' },
      body: JSON.stringify({
        forecast: forecastData.forecast,
        mape: forecastData.mape,
        generatedAt: newEntry?.generated_at || new Date().toISOString(),
        future: forecastData.future || [],
        cached: false,
        eventsCountAtGeneration: currentEventsCount,
        currentEventsCount: currentEventsCount,
        modelVersion: forecastData.metadata?.modelVersion || '1.0',
        metadata: {
          ...forecastData.metadata,
          forcedRefresh: true,
          source: 'fresh-generation'
        }
      })
    }
  }

  // Check for force refresh parameter
  const { force } = event.queryStringParameters || {}
  const shouldForceRefresh = force === 'true'
  console.log('üîç [ENTRY] Force refresh check:', {
    forceParam: force,
    shouldForceRefresh,
    queryParams: event.queryStringParameters
  })

  if (shouldForceRefresh) {
    console.log('üîÑ Force refresh requested - bypassing cache')
    // Skip cache entirely and go directly to generation
    return await generateFreshForecast()
  }

  // Get current events count for cache validation
  let currentEventsCount = 0
  try {
    const { count: eventsCountData, error: countError } = await supabase
      .from('events')
      .select('*', { count: 'exact', head: true })

    if (!countError && eventsCountData !== null) {
      currentEventsCount = eventsCountData
    }
  } catch (countErr) {
    console.warn('‚ö†Ô∏è Events count lookup failed:', countErr)
    // Don't fail - just log and continue with 0
  }

  console.log(`üìä Current events count: ${currentEventsCount}`)

  // Try to fetch latest cached forecast (with robust error handling)
  let latest = null
  try {
    const { data, error } = await supabase
      .from('forecasts')
      .select('forecast,mape,generated_at,future,events_count_at_generation,model_version')
      .order('generated_at', { ascending: false })
      .limit(1)
      .single()

    if (!error && data) {
      latest = data
      const ageMs = Date.now() - new Date(latest.generated_at).getTime()
      const FIFTEEN_MIN = 15 * 60 * 1000  // 15 minute cache

      // Cache is valid if: not forcing refresh AND age < 15min AND events count matches
      let cacheIsValid = !shouldForceRefresh &&
                        ageMs < FIFTEEN_MIN &&
                        latest?.events_count_at_generation === currentEventsCount

      console.log('üîç [DEBUG] Cache validation:', {
        shouldForceRefresh,
        ageMs,
        FIFTEEN_MIN,
        ageMinutes: Math.floor(ageMs / 1000 / 60),
        eventsCountAtGeneration: latest?.events_count_at_generation,
        currentEventsCount,
        cacheIsValid,
        generatedAt: latest.generated_at
      })

      // Force cache invalidation for old data (older than 1 hour)
      const ONE_HOUR = 60 * 60 * 1000
      if (ageMs > ONE_HOUR) {
        console.log('‚ö†Ô∏è [DEBUG] Cache is very old, forcing invalidation')
        cacheIsValid = false
      }

      // Additional debug logging
      console.log('üîç [DEBUG] Final cache decision:', {
        finalCacheIsValid: cacheIsValid,
        shouldForceRefresh,
        ageMs,
        ageMinutes: Math.floor(ageMs / 1000 / 60),
        ageHours: Math.floor(ageMs / (1000 * 60 * 60)),
        eventsCountMatch: latest?.events_count_at_generation === currentEventsCount,
        cacheWillBeUsed: cacheIsValid
      })

      if (cacheIsValid) {
        console.log('üìã Returning cached forecast (valid cache)')
        return {
          statusCode: 200,
          headers: { 'Access-Control-Allow-Origin': '*' },
          body: JSON.stringify({
            forecast: latest.forecast,
            mape: latest.mape,
            generatedAt: latest.generated_at,
            future: latest.future || [],
            cached: true,
            ageMinutes: Math.floor(ageMs / 1000 / 60),
            eventsCountAtGeneration: latest?.events_count_at_generation || 0,
            currentEventsCount: currentEventsCount,
            modelVersion: latest?.model_version || '1.0'
          })
        }
      } else {
        const reasons = []
        if (shouldForceRefresh) reasons.push('force refresh requested')
        if (ageMs >= FIFTEEN_MIN) reasons.push(`cache too old (${Math.floor(ageMs / 1000 / 60)}min)`)
        if (latest?.events_count_at_generation !== undefined && latest.events_count_at_generation !== currentEventsCount) {
          reasons.push(`events count changed (${latest.events_count_at_generation} ‚Üí ${currentEventsCount})`)
        }
        console.log(`üìã Cache invalid: ${reasons.join(', ')}`)
      }
    }
  } catch (cacheErr) {
    console.warn('‚ö†Ô∏è Cache lookup failed:', cacheErr)
    // Don't crash - just log and continue
  }

  // Try to fetch from Python service (always try in production environment)
  // Better detection: check if we're in Netlify's serverless environment
  const isNetlify = process.env.NETLIFY === 'true' || process.env.AWS_LAMBDA_FUNCTION_NAME
  const isDev = process.env.NODE_ENV === 'development' || process.env.NETLIFY_DEV === 'true'
  const shouldCallPython = isNetlify && !isDev
  
  console.log('üåç Environment check:')
  console.log('  NETLIFY:', process.env.NETLIFY)
  console.log('  AWS_LAMBDA_FUNCTION_NAME:', process.env.AWS_LAMBDA_FUNCTION_NAME ? 'Set' : 'Not set')
  console.log('  NODE_ENV:', process.env.NODE_ENV)
  console.log('  NETLIFY_DEV:', process.env.NETLIFY_DEV)
  console.log('  shouldCallPython:', shouldCallPython)
  let forecastData = null

  if (shouldCallPython) {
    console.log('üîç Fetching fresh forecast from Python service...')
    const pythonServiceUrl = process.env.PYTHON_SERVICE_URL || 'https://forecasting-service.fly.dev'
    const forecastEndpoint = `${pythonServiceUrl}/forecast/fresh`

    try {
      const controller = new AbortController()
      const timeoutId = setTimeout(() => controller.abort(), 20000) // 20s timeout
      
      console.log('üì° Calling Python service:', forecastEndpoint)
      const startTime = Date.now()
      
      const res = await fetch(forecastEndpoint, { 
        method: 'POST',
        signal: controller.signal,
        headers: {
          'X-Pythia-Version': '1.2',
          'Cache-Control': 'no-cache'
        }
      })
      
      clearTimeout(timeoutId)
      const responseTime = Date.now() - startTime
      
      console.log(`üì° Python service response: ${res.status} (${responseTime}ms)`)
      
      if (!res.ok) {
        throw new Error(`${res.status} ${res.statusText}`)
      }
      
      forecastData = await res.json()
      console.log('‚úÖ Python service success - MAPE:', forecastData.mape)
    } catch (fetchErr) {
      console.error('‚ùå Python service error:', fetchErr.message)
      console.error('‚ùå Error type:', fetchErr.name)
      forecastData = null // Will fall through to local generation
    }
  }

  // If no external service data, generate local forecast
  if (!forecastData) {
    console.log('üîß Generating local forecast for development...')
    
    // Check if cache should be considered invalid (for development mode)
    const cacheAgeMs = latest ? Date.now() - new Date(latest.generated_at).getTime() : Infinity
    const cacheEventsCount = latest?.events_count_at_generation || 0
    const shouldUseFreshData = !latest ||
                               shouldForceRefresh ||
                               cacheAgeMs > (60 * 60 * 1000) || // 1 hour
                               cacheEventsCount !== currentEventsCount

    // Use cache only if it's actually valid
    if (latest && !shouldUseFreshData) {
      console.log('üìã Using cached forecast with generated future data')
      const today = new Date()
      const futureData = []

      // Get recent traffic data for context
      const { data: recentEvents } = await supabase
        .from('events')
        .select('timestamp')
        .gte('timestamp', new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString())
        .order('timestamp', { ascending: false })
        .limit(3000)

      const todayTraffic = recentEvents ? recentEvents.filter(e =>
        new Date(e.timestamp).toDateString() === today.toDateString()
      ).length : 150

      // Realistic forecast with variation and trending
      const baseForecast = Math.max(latest.forecast, 120) // Minimum realistic traffic
      const isSpike = todayTraffic > baseForecast * 3 // Detect if today is a spike

      for (let i = 1; i <= 7; i++) {
        const futureDate = new Date(today)
        futureDate.setDate(today.getDate() + i)
        const dayOfWeek = futureDate.getDay()

        // Weekend effect (Sat=6, Sun=0)
        const weekendMultiplier = (dayOfWeek === 0 || dayOfWeek === 6) ? 0.7 : 1.0

        // Spike decay if today was a spike
        const spikeDecay = isSpike ? Math.max(0.5, 1 - (i * 0.15)) : 1.0

        // Daily variation ¬±15%
        const dailyVariation = 0.85 + Math.random() * 0.3

        const predictedValue = baseForecast * weekendMultiplier * spikeDecay * dailyVariation

        futureData.push({
          ds: futureDate.toISOString().split('T')[0],
          yhat: Math.round(predictedValue),
          yhat_lower: Math.round(predictedValue * 0.6),
          yhat_upper: Math.round(predictedValue * 1.8) // Wider bands for realism
        })
      }

      return {
        statusCode: 200,
        headers: { 'Access-Control-Allow-Origin': '*' },
        body: JSON.stringify({
          forecast: latest.forecast,
          mape: latest.mape,
          generatedAt: latest.generated_at,
          future: futureData,
          cached: true,
          eventsCountAtGeneration: latest?.events_count_at_generation || 0,
          currentEventsCount: currentEventsCount,
          modelVersion: latest?.model_version || '1.0',
          metadata: {
            algorithm: 'cached-with-fresh-future',
            source: 'cache-valid-with-fresh-future',
            cacheValid: true
          }
        })
      }
    } else {
      // Generate completely fresh forecast (cache invalid or unavailable)
      if (shouldUseFreshData && latest) {
        console.log('üîÑ Cache invalidated, generating fresh forecast')
      } else {
        console.log('üé≤ No valid cache, generating fresh forecast')
      }

      // Get recent traffic data for realistic forecasting
      const { data: recentEvents } = await supabase
        .from('events')
        .select('timestamp')
        .gte('timestamp', new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString())
        .order('timestamp', { ascending: false })
        .limit(3000)

      const today = new Date()
      const todayTraffic = recentEvents ? recentEvents.filter(e =>
        new Date(e.timestamp).toDateString() === today.toDateString()
      ).length : 150

      // Base forecast on recent actual traffic with realistic variation
      const baseTrafficLevel = Math.max(todayTraffic, 120) // Minimum realistic traffic
      const mockForecast = baseTrafficLevel * (0.9 + Math.random() * 0.3) // ¬±15% variation

      const futureData = []

      for (let i = 1; i <= 7; i++) {
        const futureDate = new Date(today)
        futureDate.setDate(today.getDate() + i)
        const dayOfWeek = futureDate.getDay()

        // Weekend effect (Sat=6, Sun=0)
        const weekendMultiplier = (dayOfWeek === 0 || dayOfWeek === 6) ? 0.7 : 1.0

        // Daily variation ¬±25% with slight upward trend
        const dailyVariation = 0.75 + Math.random() * 0.5
        const trendFactor = 1 + (i * 0.015) // Slight upward trend

        const predictedValue = mockForecast * weekendMultiplier * dailyVariation * trendFactor

        futureData.push({
          ds: futureDate.toISOString().split('T')[0],
          yhat: Math.round(predictedValue),
          yhat_lower: Math.round(predictedValue * 0.8),
          yhat_upper: Math.round(predictedValue * 1.3)
        })
      }

      forecastData = {
        forecast: mockForecast,
        mape: 12.5, // Fixed realistic MAPE - will be replaced by actual model accuracy when Python service is available
        future: futureData,
        metadata: {
          algorithm: 'fresh-local-development',
          source: 'cache-invalidated-fresh-generation',
          forcedRefresh: shouldForceRefresh,
          cacheInvalidated: shouldUseFreshData
        }
      }
    }
  }

  // Store new forecast (if available)
  let newEntry = null
  try {
    // Try to insert with new columns first
    let insertData = {
      forecast: forecastData.forecast,
      mape: forecastData.mape,
      future: forecastData.future,
      generated_at: new Date().toISOString()
    }

    // Only add new columns if they exist (to handle missing migration)
    try {
      // Test if the columns exist by doing a quick select
      await supabase.from('forecasts').select('events_count_at_generation').limit(1)
      // If no error, columns exist
      insertData.events_count_at_generation = currentEventsCount
      insertData.model_version = forecastData.metadata?.modelVersion || '1.0'
    } catch (colError) {
      console.log('üìù Using legacy forecast table schema (new columns not available)')
    }

    const { data, error: insertError } = await supabase
      .from('forecasts')
      .insert(insertData)
      .select()
      .single()

    if (insertError) throw insertError
    newEntry = data
    console.log('üíæ Stored new forecast with events_count:', currentEventsCount)
  } catch (dbErr) {
    console.error('‚ùå Error storing forecast:', dbErr)
    // Log but don't fail
  }

  return {
    statusCode: 200,
    headers: { 'Access-Control-Allow-Origin': '*' },
    body: JSON.stringify({
      forecast: forecastData.forecast,
      mape: forecastData.mape,
      generatedAt: newEntry?.generated_at || new Date().toISOString(),
      future: forecastData.future || [], // Always return future array
      cached: false,
      metadata: forecastData.metadata || {
        algorithm: 'prophet',
        source: 'python-service',
        tuning: forecastData.mape < 20 ? 'optimized' : 'default'
      }
    })
  }
}

export const handler = withTimeoutMonitoring(handlerFunction)
